#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
多功能下载器 - 集成多线程、分布式、P2P、多协议支持及QT毛玻璃界面
"""

import os
import sys
import re
import time
import json
import queue
import threading
import logging
import requests
import platform
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor

# Web框架
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS

# QT界面
from PyQt5.QtWidgets import (QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, 
                            QHBoxLayout, QListWidget, QListWidgetItem, QPushButton, 
                            QProgressBar, QLabel, QLineEdit, QFileDialog, QMessageBox,
                            QSplitter, QFrame, QScrollArea, QGroupBox, QGridLayout)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QSize, QUrl
from PyQt5.QtGui import QIcon, QColor, QBrush, QPalette, QFont, QPixmap, QGuiApplication
from PyQt5.QtWebEngineWidgets import QWebEngineView

# P2P支持
try:
    import libtorrent as lt
except ImportError:
    lt = None
    print("警告: libtorrent未安装，P2P功能不可用")

# 多协议支持
try:
    import pysftp
except ImportError:
    pysftp = None
    print("警告: pysftp未安装，SFTP功能不可用")

# 日志配置
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.FileHandler("downloader.log"), logging.StreamHandler()]
)
logger = logging.getLogger("MultiDownloader")

# 确保中文显示正常
if platform.system() == "Windows":
    os.environ["QT_FONT_DPI"] = "96"

# 下载任务类
class DownloadTask:
    def __init__(self, url, save_path, task_type="http", priority=2, headers=None, proxy=None):
        self.url = url
        self.save_path = save_path
        self.task_type = task_type  # http, ftp, sftp, torrent
        self.priority = priority  # 1:低, 2:中, 3:高
        self.headers = headers or {}
        self.proxy = proxy
        self.id = hash(url + save_path + task_type)
        self.status = "pending"  # pending, downloading, completed, failed, paused
        self.progress = 0
        self.total_size = 0
        self.start_time = None
        self.end_time = None
        self.threads = 16 if task_type == "http" else 1
        self.chunk_size = 1024 * 1024  # 1MB per chunk
        self.chunk_status = {}
        self.extra = {}  # 存储额外信息，如torrent的info_hash
    
    def to_dict(self):
        return {
            "id": self.id,
            "url": self.url,
            "save_path": self.save_path,
            "task_type": self.task_type,
            "priority": self.priority,
            "status": self.status,
            "progress": self.progress,
            "total_size": self.total_size,
            "threads": self.threads,
            "start_time": str(self.start_time) if self.start_time else "",
            "end_time": str(self.end_time) if self.end_time else ""
        }
    
    @classmethod
    def from_dict(cls, data):
        task = cls(
            data["url"],
            data["save_path"],
            data["task_type"],
            data["priority"]
        )
        task.id = data["id"]
        task.status = data["status"]
        task.progress = data["progress"]
        task.total_size = data["total_size"]
        task.threads = data["threads"]
        task.start_time = datetime.strptime(data["start_time"], "%Y-%m-%d %H:%M:%S.%f") if data["start_time"] else None
        task.end_time = datetime.strptime(data["end_time"], "%Y-%m-%d %H:%M:%S.%f") if data["end_time"] else None
        return task


# 下载管理器核心
class DownloadManager:
    def __init__(self, max_threads=32):
        self.max_threads = max_threads
        self.task_queue = queue.PriorityQueue()  # 优先队列
        self.running_tasks = {}  # 存储正在运行的任务
        self.thread_pool = ThreadPoolExecutor(max_workers=max_threads)
        self.task_lock = threading.Lock()
        self.is_running = False
        self.download_speed = 0
        self.downloaded_bytes = 0
        self.last_speed_update = time.time()
        
        # P2P客户端
        self.torrent_session = None
        if lt:
            self.init_torrent_session()
    
    def init_torrent_session(self):
        """初始化P2P会话"""
        self.torrent_session = lt.session()
        self.torrent_session.listen_on(6881, 6891)
        logger.info("P2P会话初始化完成")
    
    def add_task(self, task):
        """添加下载任务"""
        with self.task_lock:
            self.task_queue.put((-task.priority, task))  # 负优先级实现高优先级先出队
            logger.info(f"添加任务: {task.url}, 类型: {task.task_type}")
            if not self.is_running:
                self.start()
    
    def start(self):
        """启动下载管理器"""
        if self.is_running:
            return
        
        self.is_running = True
        logger.info("下载管理器启动")
        
        # 启动任务处理线程
        self.process_thread = threading.Thread(target=self.process_tasks)
        self.process_thread.daemon = True
        self.process_thread.start()
        
        # 启动速度监控线程
        self.speed_thread = threading.Thread(target=self.monitor_speed)
        self.speed_thread.daemon = True
        self.speed_thread.start()
    
    def stop(self):
        """停止下载管理器"""
        self.is_running = False
        logger.info("下载管理器停止")
    
    def process_tasks(self):
        """处理任务队列"""
        while self.is_running:
            try:
                if not self.task_queue.empty():
                    _, task = self.task_queue.get()
                    self.running_tasks[task.id] = task
                    logger.info(f"处理任务: {task.url}")
                    
                    # 根据任务类型执行下载
                    if task.task_type == "http":
                        self.thread_pool.submit(self.download_http_task, task)
                    elif task.task_type == "torrent" and lt:
                        self.thread_pool.submit(self.download_torrent_task, task)
                    elif task.task_type == "sftp" and pysftp:
                        self.thread_pool.submit(self.download_sftp_task, task)
                    else:
                        logger.error(f"不支持的任务类型: {task.task_type}")
                        with self.task_lock:
                            task.status = "failed"
                            if task.id in self.running_tasks:
                                del self.running_tasks[task.id]
            except Exception as e:
                logger.error(f"处理任务时出错: {e}")
                time.sleep(1)
    
    def monitor_speed(self):
        """监控下载速度"""
        last_bytes = 0
        while self.is_running:
            time.sleep(1)
            with self.task_lock:
                current_bytes = self.downloaded_bytes
                self.download_speed = (current_bytes - last_bytes) / 1024  # KB/s
                last_bytes = current_bytes
    
    def download_http_task(self, task):
        """下载HTTP任务"""
        task.status = "downloading"
        task.start_time = time.time()
        
        try:
            # 初始化断点续传
            if os.path.exists(task.save_path):
                task.progress = os.path.getsize(task.save_path)
                logger.info(f"从{task.progress}字节处续传")
            
            # 获取文件总大小
            task.total_size = self.get_http_file_size(task.url, task.headers, task.proxy)
            if task.total_size == 0:
                task.status = "failed"
                logger.error(f"无法获取文件大小: {task.url}")
                return
            
            # 创建临时文件
            temp_file = task.save_path + ".part"
            chunk_dir = os.path.join(os.path.dirname(temp_file), f"chunks_{task.id}")
            os.makedirs(chunk_dir, exist_ok=True)
            
            # 初始化块状态
            if not task.chunk_status:
                task.chunk_status = {
                    i: {"start": i * task.chunk_size, "end": min((i+1)*task.chunk_size, task.total_size), "downloaded": 0}
                    for i in range((task.total_size + task.chunk_size - 1) // task.chunk_size)
                }
            
            # 下载每个块
            available_threads = min(task.threads, len(task.chunk_status), self.max_threads)
            with ThreadPoolExecutor(max_workers=available_threads) as executor:
                futures = []
                for chunk_id, chunk_info in task.chunk_status.items():
                    if chunk_info["downloaded"] >= chunk_info["end"] - chunk_info["start"]:
                        continue
                    
                    futures.append(executor.submit(
                        self.download_http_chunk, task, chunk_id, chunk_info, temp_file, chunk_dir
                    ))
                
                for future in as_completed(futures):
                    try:
                        future.result()
                    except Exception as e:
                        logger.error(f"块下载错误: {e}")
            
            # 合并块
            self.merge_chunks(task, temp_file, chunk_dir)
            
            # 完成任务
            with self.task_lock:
                task.status = "completed"
                task.progress = task.total_size
                task.end_time = time.time()
                self.downloaded_bytes += task.total_size
                logger.info(f"任务完成: {task.url}, 大小: {task.total_size/1024/1024:.2f}MB")
        
        except Exception as e:
            with self.task_lock:
                task.status = "failed"
                task.end_time = time.time()
                logger.error(f"下载失败: {task.url}, 错误: {e}")
        finally:
            with self.task_lock:
                if task.id in self.running_tasks:
                    del self.running_tasks[task.id]
            self.cleanup_temp_files(task)
    
    def get_http_file_size(self, url, headers, proxy):
        """获取HTTP文件大小"""
        try:
            proxies = {"http": proxy, "https": proxy} if proxy else None
            response = requests.head(url, headers=headers, proxies=proxies, timeout=10)
            if response.status_code in [200, 206]:
                return int(response.headers.get("Content-Length", 0))
            return 0
        except Exception as e:
            logger.error(f"获取文件大小失败: {e}")
            return 0
    
    def download_http_chunk(self, task, chunk_id, chunk_info, temp_file, chunk_dir):
        """下载HTTP块"""
        chunk_file = os.path.join(chunk_dir, f"chunk_{chunk_id}.part")
        start_byte = chunk_info["start"] + chunk_info["downloaded"]
        end_byte = chunk_info["end"] - 1
        
        if os.path.exists(chunk_file) and os.path.getsize(chunk_file) == (end_byte - start_byte + 1):
            chunk_info["downloaded"] = end_byte - start_byte + 1
            with self.task_lock:
                task.progress = sum(chunk["downloaded"] for chunk in task.chunk_status.values())
            return
        
        headers = task.headers.copy()
        headers["Range"] = f"bytes={start_byte}-{end_byte}"
        
        proxies = {"http": task.proxy, "https": task.proxy} if task.proxy else None
        
        retries = 3
        for i in range(retries):
            try:
                with requests.get(task.url, headers=headers, proxies=proxies, stream=True, timeout=15) as response:
                    if response.status_code == 206:
                        with open(chunk_file, 'ab') as f:
                            for data in response.iter_content(chunk_size=1024*100):
                                f.write(data)
                                with self.task_lock:
                                    self.downloaded_bytes += len(data)
                        
                        downloaded = os.path.getsize(chunk_file)
                        chunk_info["downloaded"] = downloaded
                        with self.task_lock:
                            task.progress = sum(chunk["downloaded"] for chunk in task.chunk_status.values())
                        return
                    else:
                        logger.warning(f"获取块失败，状态码: {response.status_code}")
                        time.sleep(2)
            except Exception as e:
                logger.warning(f"块下载错误，重试 {i+1}/{retries}: {e}")
                time.sleep(2)
        
        logger.error(f"块 {chunk_id} 下载失败")
    
    def merge_chunks(self, task, temp_file, chunk_dir):
        """合并块"""
        try:
            with open(temp_file, 'wb') as f:
                for i in range(len(task.chunk_status)):
                    chunk_file = os.path.join(chunk_dir, f"chunk_{i}.part")
                    if os.path.exists(chunk_file):
                        with open(chunk_file, 'rb') as chunk_f:
                            f.write(chunk_f.read())
            
            if os.path.exists(task.save_path):
                os.remove(task.save_path)
            os.rename(temp_file, task.save_path)
        except Exception as e:
            logger.error(f"合并块失败: {e}")
    
    def cleanup_temp_files(self, task):
        """清理临时文件"""
        temp_file = task.save_path + ".part"
        chunk_dir = os.path.join(os.path.dirname(temp_file), f"chunks_{task.id}")
        
        if os.path.exists(temp_file):
            os.remove(temp_file)
        
        if os.path.exists(chunk_dir):
            shutil.rmtree(chunk_dir, ignore_errors=True)
    
    def download_torrent_task(self, task):
        """下载Torrent任务"""
        if not self.torrent_session:
            task.status = "failed"
            logger.error("P2P会话未初始化")
            return
        
        task.status = "downloading"
        task.start_time = time.time()
        
        try:
            # 解析Torrent文件或磁力链接
            if task.url.startswith("magnet:"):
                # 磁力链接
                params = {
                    "save_path": os.path.dirname(task.save_path),
                    "paused": False,
                    "duplicate_is_error": True,
                    "download_mode": True
                }
                handle = self.torrent_session.add_magnet_uri(task.url, params)
                task.extra["handle"] = handle.info_hash()
                logger.info(f"添加磁力链接: {task.url}")
            else:
                # Torrent文件
                with open(task.url, 'rb') as f:
                    torrent_data = f.read()
                
                torrent = lt.bdecode(torrent_data)
                info = lt.torrent_info(torrent)
                params = {
                    "ti": info,
                    "save_path": os.path.dirname(task.save_path),
                    "paused": False,
                    "duplicate_is_error": True,
                    "download_mode": True
                }
                handle = self.torrent_session.add_torrent(params)
                task.extra["handle"] = handle.info_hash()
                logger.info(f"添加Torrent文件: {task.url}")
            
            # 等待元数据
            logger.info("等待Torrent元数据...")
            while not handle.has_metadata() and self.is_running:
                time.sleep(0.5)
            
            if not self.is_running:
                task.status = "failed"
                return
            
            # 获取Torrent信息
            info = handle.get_torrent_info()
            task.total_size = info.total_size()
            task.save_path = os.path.join(params["save_path"], info.name())
            
            # 监控下载进度
            while handle.status().state != lt.torrent_state.seeding and self.is_running:
                status = handle.status()
                with self.task_lock:
                    task.progress = int(status.progress * task.total_size)
                    task.status = "downloading"
                
                time.sleep(1)
            
            if self.is_running:
                with self.task_lock:
                    task.status = "completed"
                    task.progress = task.total_size
                    task.end_time = time.time()
                    self.downloaded_bytes += task.total_size
                logger.info(f"Torrent下载完成: {info.name()}, 大小: {task.total_size/1024/1024:.2f}MB")
            else:
                task.status = "paused"
        
        except Exception as e:
            with self.task_lock:
                task.status = "failed"
                task.end_time = time.time()
                logger.error(f"Torrent下载失败: {e}")
        finally:
            with self.task_lock:
                if task.id in self.running_tasks:
                    del self.running_tasks[task.id]
    
    def download_sftp_task(self, task):
        """下载SFTP任务"""
        task.status = "downloading"
        task.start_time = time.time()
        
        try:
            parsed = urlparse(task.url)
            host = parsed.hostname
            port = parsed.port or 22
            username = parsed.username
            password = parsed.password
            
            with pysftp.Connection(host, port=port, username=username, password=password) as sftp:
                # 检查文件是否存在
                if not sftp.exists(parsed.path):
                    task.status = "failed"
                    logger.error(f"SFTP文件不存在: {task.url}")
                    return
                
                # 获取文件大小
                task.total_size = sftp.stat(parsed.path).st_size
                
                # 下载文件
                sftp.get(parsed.path, task.save_path)
                
                with self.task_lock:
                    task.status = "completed"
                    task.progress = task.total_size
                    task.end_time = time.time()
                    self.downloaded_bytes += task.total_size
                logger.info(f"SFTP下载完成: {task.url}, 大小: {task.total_size/1024/1024:.2f}MB")
        
        except Exception as e:
            with self.task_lock:
                task.status = "failed"
                task.end_time = time.time()
                logger.error(f"SFTP下载失败: {e}")
        finally:
            with self.task_lock:
                if task.id in self.running_tasks:
                    del self.running_tasks[task.id]
    
    def get_task_status(self, task_id):
        """获取任务状态"""
        with self.task_lock:
            if task_id in self.running_tasks:
                return self.running_tasks[task_id].to_dict()
            # 检查队列中的任务
            for _, task in list(self.task_queue.queue):
                if task.id == task_id:
                    return task.to_dict()
        return None
    
    def get_all_tasks(self):
        """获取所有任务"""
        tasks = list(self.running_tasks.values())
        for _, task in list(self.task_queue.queue):
            tasks.append(task)
        return [task.to_dict() for task in tasks]
    
    def pause_task(self, task_id):
        """暂停任务"""
        with self.task_lock:
            # 暂停Torrent任务
            for task in list(self.running_tasks.values()):
                if task.id == task_id and task.task_type == "torrent" and lt:
                    if hasattr(task.extra, "handle"):
                        task.extra["handle"].pause()
                        task.status = "paused"
                        return True
            
            # 其他任务标记为暂停
            for _, task in list(self.task_queue.queue):
                if task.id == task_id:
                    task.status = "paused"
                    return True
            if task_id in self.running_tasks:
                self.running_tasks[task_id].status = "paused"
                return True
        return False
    
    def resume_task(self, task_id):
        """恢复任务"""
        with self.task_lock:
            # 恢复Torrent任务
            for task in list(self.running_tasks.values()):
                if task.id == task_id and task.task_type == "torrent" and lt:
                    if hasattr(task.extra, "handle"):
                        task.extra["handle"].resume()
                        task.status = "downloading"
                        return True
            
            # 其他任务标记为恢复
            for _, task in list(self.task_queue.queue):
                if task.id == task_id and task.status == "paused":
                    task.status = "pending"
                    return True
            if task_id in self.running_tasks and self.running_tasks[task_id].status == "paused":
                self.running_tasks[task_id].status = "downloading"
                return True
        return False
    
    def delete_task(self, task_id):
        """删除任务"""
        with self.task_lock:
            deleted = False
            # 从队列中删除
            new_queue = []
            for item in list(self.task_queue.queue):
                _, task = item
                if task.id != task_id:
                    new_queue.append(item)
                else:
                    deleted = True
                    logger.info(f"从队列删除任务: {task.url}")
            
            # 清空队列并重新填充
            while not self.task_queue.empty():
                self.task_queue.get()
            
            for item in new_queue:
                self.task_queue.put(item)
            
            # 从运行任务中删除
            if task_id in self.running_tasks:
                task = self.running_tasks[task_id]
                del self.running_tasks[task_id]
                self.cleanup_temp_files(task)
                if os.path.exists(task.save_path):
                    os.remove(task.save_path)
                deleted = True
                logger.info(f"删除任务: {task.url}")
            
            return deleted


# Web API 服务器
class WebServer(threading.Thread):
    def __init__(self, download_manager, port=5000):
        super().__init__()
        self.daemon = True
        self.download_manager = download_manager
        self.port = port
        self.app = Flask(__name__)
        CORS(self.app)
        self.setup_routes()
    
    def setup_routes(self):
        """设置路由"""
        @self.app.route('/')
        def index():
            return render_template('index.html')
        
        @self.app.route('/api/tasks', methods=['GET'])
        def get_tasks():
            tasks = self.download_manager.get_all_tasks()
            return jsonify(tasks)
        
        @self.app.route('/api/task/<task_id>', methods=['GET'])
        def get_task(task_id):
            task = self.download_manager.get_task_status(int(task_id))
            if task:
                return jsonify(task)
            return jsonify({"error": "任务不存在"}), 404
        
        @self.app.route('/api/task', methods=['POST'])
        def add_task():
            data = request.json
            if not data:
                return jsonify({"error": "缺少任务数据"}), 400
            
            task = DownloadTask(
                data["url"],
                data["save_path"],
                data.get("task_type", "http"),
                data.get("priority", 2)
            )
            self.download_manager.add_task(task)
            return jsonify(task.to_dict()), 201
        
        @self.app.route('/api/task/<task_id>/pause', methods=['POST'])
        def pause_task(task_id):
            if self.download_manager.pause_task(int(task_id)):
                return jsonify({"status": "paused"})
            return jsonify({"error": "暂停任务失败"}), 400
        
        @self.app.route('/api/task/<task_id>/resume', methods=['POST'])
        def resume_task(task_id):
            if self.download_manager.resume_task(int(task_id)):
                return jsonify({"status": "resumed"})
            return jsonify({"error": "恢复任务失败"}), 400
        
        @self.app.route('/api/task/<task_id>/delete', methods=['DELETE'])
        def delete_task(task_id):
            if self.download_manager.delete_task(int(task_id)):
                return jsonify({"status": "deleted"})
            return jsonify({"error": "删除任务失败"}), 400
        
        @self.app.route('/api/speed', methods=['GET'])
        def get_speed():
            return jsonify({"speed": self.download_manager.download_speed})
    
    def run(self):
        """运行Web服务器"""
        # 创建模板目录（如果不存在）
        template_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "templates")
        if not os.path.exists(template_dir):
            os.makedirs(template_dir)
            # 创建简单的HTML模板
            with open(os.path.join(template_dir, "index.html"), 'w', encoding='utf-8') as f:
                f.write("""
                <!DOCTYPE html>
                <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>多功能下载器</title>
                    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        .task-list { margin-top: 20px; }
                        .task-item { padding: 10px; border: 1px solid #ddd; margin-bottom: 10px; }
                        .progress-bar { width: 100%; background-color: #f0f0f0; height: 20px; }
                        .progress { height: 100%; background-color: #4CAF50; }
                    </style>
                </head>
                <body>
                    <h1>多功能下载器</h1>
                    <div>
                        <input type="text" id="url-input" placeholder="输入下载链接">
                        <input type="text" id="path-input" placeholder="保存路径" value="./downloads/">
                        <button id="add-task">添加任务</button>
                    </div>
                    <div>当前下载速度: <span id="speed">0 KB/s</span></div>
                    <div class="task-list" id="task-list">
                        <!-- 任务将在这里显示 -->
                    </div>
                    <script>
                        function updateTasks() {
                            axios.get('/api/tasks')
                                .then(response => {
                                    const taskList = document.getElementById('task-list');
                                    taskList.innerHTML = '';
                                    
                                    response.data.forEach(task => {
                                        const taskItem = document.createElement('div');
                                        taskItem.className = 'task-item';
                                        
                                        let statusColor = 'gray';
                                        if (task.status === 'downloading') statusColor = 'blue';
                                        if (task.status === 'completed') statusColor = 'green';
                                        if (task.status === 'failed') statusColor = 'red';
                                        if (task.status === 'paused') statusColor = 'orange';
                                        
                                        taskItem.innerHTML = `
                                            <div>URL: ${task.url}</div>
                                            <div>状态: <span style="color: ${statusColor}">${task.status}</span></div>
                                            <div>进度: ${(task.progress / 1024 / 1024).toFixed(2)}MB / ${(task.total_size / 1024 / 1024).toFixed(2)}MB</div>
                                            <div class="progress-bar">
                                                <div class="progress" style="width: ${task.total_size > 0 ? (task.progress / task.total_size * 100) : 0}%"></div>
                                            </div>
                                            <div>
                                                <button onclick="pauseTask(${task.id})">暂停</button>
                                                <button onclick="resumeTask(${task.id})">恢复</button>
                                                <button onclick="deleteTask(${task.id})">删除</button>
                                            </div>
                                        `;
                                        taskList.appendChild(taskItem);
                                    });
                                })
                                .catch(error => console.error(error));
                        }
                        
                        function updateSpeed() {
                            axios.get('/api/speed')
                                .then(response => {
                                    document.getElementById('speed').textContent = `${response.data.speed.toFixed(2)} KB/s`;
                                })
                                .catch(error => console.error(error));
                        }
                        
                        function pauseTask(taskId) {
                            axios.post(`/api/task/${taskId}/pause`)
                                .then(() => updateTasks())
                                .catch(error => console.error(error));
                        }
                        
                        function resumeTask(taskId) {
                            axios.post(`/api/task/${taskId}/resume`)
                                .then(() => updateTasks())
                                .catch(error => console.error(error));
                        }
                        
                        function deleteTask(taskId) {
                            axios.delete(`/api/task/${taskId}/delete`)
                                .then(() => updateTasks())
                                .catch(error => console.error(error));
                        }
                        
                        document.getElementById('add-task').addEventListener('click', () => {
                            const url = document.getElementById('url-input').value;
                            const path = document.getElementById('path-input').value;
                            if (url) {
                                axios.post('/api/task', {
                                    url: url,
                                    save_path: path,
                                    task_type: url.startsWith('magnet:') ? 'torrent' : 'http'
                                })
                                .then(() => updateTasks())
                                .catch(error => console.error(error));
                            }
                        });
                        
                        // 定时更新
                        setInterval(updateTasks, 1000);
                        setInterval(updateSpeed, 1000);
                        updateTasks();
                    </script>
                </body>
                </html>
                """)
        
        self.app.run(host='0.0.0.0', port=self.port, debug=False)


# QT界面类
class DownloadTaskItem(QWidget):
    taskClicked = pyqtSignal(str)
    pauseClicked = pyqtSignal(str)
    resumeClicked = pyqtSignal(str)
    deleteClicked = pyqtSignal(str)
    
    def __init__(self, task_id, task_data, parent=None):
        super().__init__(parent)
        self.task_id = task_id
        self.task_data = task_data
        self.init_ui()
    
    def init_ui(self):
        layout = QVBoxLayout()
        
        # 任务信息
        info_layout = QHBoxLayout()
        url_label = QLabel(self.task_data["url"])
        url_label.setWordWrap(True)
        url_label.setTextInteractionFlags(Qt.TextSelectableByMouse)
        info_layout.addWidget(url_label)
        
        status_label = QLabel(f"状态: {self.task_data['status']}")
        if self.task_data["status"] == "downloading":
            status_label.setStyleSheet("color: blue;")
        elif self.task_data["status"] == "completed":
            status_label.setStyleSheet("color: green;")
        elif self.task_data["status"] == "failed":
            status_label.setStyleSheet("color: red;")
        elif self.task_data["status"] == "paused":
            status_label.setStyleSheet("color: orange;")
        info_layout.addWidget(status_label)
        
        layout.addLayout(info_layout)
        
        # 进度条
        progress_layout = QHBoxLayout()
        progress_label = QLabel(f"进度: {self.task_data['progress']/1024/1024:.2f}MB / {self.task_data['total_size']/1024/1024:.2f}MB")
        progress_bar = QProgressBar()
        progress_bar.setRange(0, 100)
        progress_bar.setValue(int(self.task_data["progress"] / self.task_data["total_size"] * 100) if self.task_data["total_size"] > 0 else 0)
        
        progress_layout.addWidget(progress_label)
        progress_layout.addWidget(progress_bar)
        layout.addLayout(progress_layout)
        
        # 按钮
        button_layout = QHBoxLayout()
        pause_btn = QPushButton("暂停")
        resume_btn = QPushButton("恢复")
        delete_btn = QPushButton("删除")
        
        pause_btn.clicked.connect(lambda: self.pauseClicked.emit(self.task_id))
        resume_btn.clicked.connect(lambda: self.resumeClicked.emit(self.task_id))
        delete_btn.clicked.connect(lambda: self.deleteClicked.emit(self.task_id))
        
        button_layout.addWidget(pause_btn)
        button_layout.addWidget(resume_btn)
        button_layout.addWidget(delete_btn)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
        self.setStyleSheet("""
            DownloadTaskItem {
                background-color: rgba(255, 255, 255, 180);
                border-radius: 5px;
                margin: 5px;
                padding: 10px;
            }
            QProgressBar {
                border: 1px solid #bbb;
                border-radius: 5px;
                background-color: #f0f0f0;
                height: 15px;
            }
            QProgressBar::chunk {
                background-color: #4CAF50;
                border-radius: 5px;
                width: 10px;
            }
        """)


class MainWindow(QMainWindow):
    def __init__(self, download_manager):
        super().__init__()
        self.download_manager = download_manager
        self.init_ui()
        self.update_timer = None
        self.web_view = None
        self.setup_web_server()
    
    def setup_web_server(self):
        """设置Web服务器"""
        self.web_server = WebServer(self.download_manager)
        self.web_server.start()
        logger.info(f"Web服务器运行在 http://localhost:{self.web_server.port}")
    
    def init_ui(self):
        """初始化用户界面"""
        self.setWindowTitle("多功能下载器")
        self.setMinimumSize(800, 600)
        
        # 设置毛玻璃效果
        if platform.system() == "Windows" and hasattr(Qt, 'AA_UseWindows10Effects'):
            QApplication.setAttribute(Qt.AA_UseWindows10Effects, True)
        
        self.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        central_widget = QWidget()
        central_widget.setStyleSheet("background-color: rgba(255, 255, 255, 150); border-radius: 10px;")
        self.setCentralWidget(central_widget)
        
        main_layout = QVBoxLayout(central_widget)
        
        # 标题栏
        title_bar = QHBoxLayout()
        title_label = QLabel("多功能下载器")
        title_label.setFont(QFont("Microsoft YaHei", 14, QFont.Bold))
        title_bar.addWidget(title_label)
        
        close_btn = QPushButton("X")
        close_btn.setFixedSize(30, 30)
        close_btn.clicked.connect(self.close)
        title_bar.addWidget(close_btn)
        
        title_bar.setContentsMargins(15, 10, 15, 10)
        main_layout.addLayout(title_bar)
        
        # 分割线
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line)
        
        # 下载速度
        speed_layout = QHBoxLayout()
        speed_label = QLabel("当前下载速度:")
        self.speed_value = QLabel("0 KB/s")
        speed_layout.addWidget(speed_label)
        speed_layout.addWidget(self.speed_value)
        main_layout.addLayout(speed_layout)
        
        # 任务列表
        task_list_layout = QVBoxLayout()
        task_label = QLabel("下载任务:")
        task_label.setFont(QFont("Microsoft YaHei", 12))
        task_list_layout.addWidget(task_label)
        
        self.task_scroll_area = QScrollArea()
        self.task_scroll_area.setWidgetResizable(True)
        self.task_scroll_area.setStyleSheet("background-color: transparent;")
        
        self.task_widget = QWidget()
        self.task_layout = QVBoxLayout(self.task_widget)
        self.task_layout.setSpacing(5)
        self.task_scroll_area.setWidget(self.task_widget)
        
        task_list_layout.addWidget(self.task_scroll_area)
        main_layout.addLayout(task_list_layout)
        
        # 任务控制区
        control_layout = QHBoxLayout()
        self.url_input = QLineEdit()
        self.url_input.setPlaceholderText("输入下载链接 (HTTP/FTP/磁力链接)")
        
        self.path_input = QLineEdit()
        self.path_input.setText(os.path.join(os.getcwd(), "downloads"))
        
        browse_btn = QPushButton("浏览")
        browse_btn.clicked.connect(self.browse_path)
        
        add_btn = QPushButton("添加任务")
        add_btn.clicked.connect(self.add_task)
        
        control_layout.addWidget(self.url_input, 3)
        control_layout.addWidget(self.path_input, 2)
        control_layout.addWidget(browse_btn, 1)
        control_layout.addWidget(add_btn, 1)
        main_layout.addLayout(control_layout)
        
        # 初始化更新定时器
        self.update_timer = self.startTimer(1000)
    
    def browse_path(self):
        """浏览保存路径"""
        path = QFileDialog.getExistingDirectory(self, "选择保存路径")
        if path:
            self.path_input.setText(path)
    
    def add_task(self):
        """添加新任务"""
        url = self.url_input.text()
        if not url:
            QMessageBox.warning(self, "警告", "请输入下载链接")
            return
        
        save_path = self.path_input.text()
        if not os.path.exists(save_path):
            try:
                os.makedirs(save_path)
            except:
                QMessageBox.warning(self, "警告", "保存路径无效")
                return
        
        # 确定任务类型
        task_type = "http"
        if url.startswith("magnet:"):
            task_type = "torrent"
        elif url.startswith("sftp:"):
            task_type = "sftp"
        
        task = DownloadTask(url, save_path, task_type)
        self.download_manager.add_task(task)
        self.url_input.clear()
    
    def timerEvent(self, event):
        """定时器事件，更新任务列表和速度"""
        if event.timerId() == self.update_timer:
            self.update_speed()
            self.update_task_list()
    
    def update_speed(self):
        """更新下载速度"""
        speed = self.download_manager.download_speed
        self.speed_value.setText(f"{speed:.2f} KB/s")
    
    def update_task_list(self):
        """更新任务列表"""
        tasks = self.download_manager.get_all_tasks()
        
        # 清除现有任务项
        while self.task_layout.count():
            item = self.task_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        # 添加新任务项
        for task in tasks:
            task_item = DownloadTaskItem(str(task["id"]), task)
            task_item.taskClicked.connect(self.task_clicked)
            task_item.pauseClicked.connect(self.pause_task)
            task_item.resumeClicked.connect(self.resume_task)
            task_item.deleteClicked.connect(self.delete_task)
            self.task_layout.addWidget(task_item)
    
    def task_clicked(self, task_id):
        """任务点击事件"""
        pass
    
    def pause_task(self, task_id):
        """暂停任务"""
        self.download_manager.pause_task(int(task_id))
    
    def resume_task(self, task_id):
        """恢复任务"""
        self.download_manager.resume_task(int(task_id))
    
    def delete_task(self, task_id):
        """删除任务"""
        self.download_manager.delete_task(int(task_id))


# 主程序
if __name__ == "__main__":
    # 确保下载目录存在
    if not os.path.exists("downloads"):
        os.makedirs("downloads")
    
    # 初始化下载管理器
    download_manager = DownloadManager(max_threads=32)
    
    # 启动QT应用
    app = QApplication(sys.argv)
    app.setStyle("Fusion")  # 使用Fusion风格以支持毛玻璃效果
    
    # 设置全局样式
    app.setStyleSheet("""
        QMainWindow, QWidget {
            background-color: rgba(255, 255, 255, 150);
            color: #333;
        }
        QPushButton {
            background-color: rgba(0, 120, 212, 200);
            color: white;
            border-radius: 5px;
            padding: 5px 10px;
        }
        QPushButton:hover {
            background-color: rgba(0, 120, 212, 230);
        }
        QPushButton:pressed {
            background-color: rgba(0, 120, 212, 180);
        }
        QLabel {
            color: #333;
        }
        QLineEdit {
            background-color: rgba(255, 255, 255, 200);
            border: 1px solid #bbb;
            border-radius: 5px;
            padding: 5px;
        }
    """)
    
    window = MainWindow(download_manager)
    window.show()
    
    # 启动下载管理器
    download_manager.start()
    
    sys.exit(app.exec_())